using System.Collections;
using UnityEngine;
using UnityEngine.AI;

public class NavMeshMovement : MonoBehaviour
{
    // Global variables used throughout the script. May be changed from the Unity Editor.
    public float wanderWaitTime = 2.0f; // in seconds
    public float wanderTriggerChance = 0.3f; // has to be between 0 and 1
    public float avoidDistance = 4.0f;
    public float cooldownTime = 30f;
    public float agentSpeed = 6.0f;
    public float agentAcceleration = 8.0f;
    public float baitDetectionDistance = 6.0f;
    public float baitStopDistance = 6.0f;
    public float baitCooldownTime = 1f; // in seconds

    private float baseSpeed; // used to remember the speed of the NavMesh agent

    [SerializeField]
    private Transform player;

    [SerializeField]
    private Transform bait;

    private Animator animator;
    private NavMeshAgent agent;
    private Coroutine currentCoroutine;

    private bool hasReachedBait = false; // indicates if the object has reached the bait
    private bool immobileFromBait = false; // indicates if mammoth is slow to react after reaching bait

    // Variables used for the GameObject's avoiding behavior.
    private bool isAvoiding = false;
    private bool recentlyAvoided = false;
    private int increment = 1;

    /// <summary>
    /// Start is called before the first frame update.
    /// Initiates the GameObject's properties.
    /// </summary>

    void Start()
    {
        animator = GetComponent<Animator>();
        agent = GetComponent<NavMeshAgent>();

        if (animator != null)
        {
            animator.SetBool("Moving", false);
        }

        if (agent == null)
        {
            Debug.LogError("NavMeshAgent component not found!");
            return;
        }

        baseSpeed = agentSpeed;
        agent.speed = agentSpeed;
        agent.acceleration = agentAcceleration;
        agent.stoppingDistance = baitStopDistance;

        currentCoroutine = StartCoroutine(Wander());
    }

    /// <summary>
    /// Wandering movement of the asset. Follows a randomly generated
    /// path.
    /// </summary>
    IEnumerator Wander()
    {
        while (true)
        {
            yield return new WaitForSeconds(wanderWaitTime);
            if (Random.value < wanderTriggerChance)
            {
                if (animator != null)
                {
                    animator.SetBool("Moving", true);
                }

                Vector3 wanderTarget = GetRandomNavMeshLocation();
                Debug.Log("Wandering to: " + wanderTarget);
                agent.SetDestination(wanderTarget);

                while (agent.pathPending || agent.remainingDistance > agent.stoppingDistance)
                {
                    yield return null;
                }

                if (animator != null)
                {
                    animator.SetBool("Moving", false);
                }
            }
        }
    }

    /// <summary>
    /// Generates a random position on the NavMesh. The NavMesh agent,
    /// the GameObject, will move in the direction generated by this method.
    /// </summary>
    /// <returns> A vector pointing towards the random direction </returns>
    Vector3 GetRandomNavMeshLocation()
    {
        Vector3 randomDirection = Random.insideUnitSphere * avoidDistance;
        randomDirection += transform.position;
        NavMeshHit navHit;
        NavMesh.SamplePosition(randomDirection, out navHit, avoidDistance, NavMesh.AllAreas);
        return navHit.position;
    }

    /// <summary>
    /// Avoiding behavior of the GameObject. It moves away from the player.
    /// TODO: Implement faster animation for fast speeds.
    /// </summary>
    IEnumerator Avoid()
    {
        isAvoiding = true;
        Vector3 directionAwayFromPlayer = (transform.position - player.position).normalized;

        if (recentlyAvoided && increment < 2)
        {
            increment += 1;
        }

        float modifier = Mathf.Pow(1.3f, increment);
        agent.speed = baseSpeed * modifier;

        Vector3 avoidTarget = transform.position + directionAwayFromPlayer * (modifier * avoidDistance);

        NavMeshHit navHit;
        NavMesh.SamplePosition(avoidTarget, out navHit, avoidDistance, NavMesh.AllAreas);

        if (animator != null)
        {
            animator.SetBool("Moving", true);
        }

        Debug.Log("Avoiding to: " + navHit.position);
        agent.SetDestination(navHit.position);

        while (agent.pathPending || agent.remainingDistance > agent.stoppingDistance)
        {
            yield return null;
        }

        if (animator != null)
        {
            animator.SetBool("Moving", false);
        }

        if (!recentlyAvoided)
        {
            recentlyAvoided = true;
        }

        isAvoiding = false;

        currentCoroutine = StartCoroutine(Wander());

        StartCoroutine(AvoidCooldown());
    }

    /// <summary>
    /// Helper method that makes the GameObject moves towards
    /// the designated bait object.
    /// </summary>
    /// <returns></returns>
    IEnumerator MoveToBait()
    {
        Debug.Log("Moving to bait");
        if (animator != null)
        {
            animator.SetBool("Moving", true);
        }

        Vector3 baitPosition = bait.position;
        Vector3 directionToBait = (baitPosition - transform.position).normalized;
        Vector3 stopPosition = baitPosition - directionToBait * baitStopDistance;

        agent.SetDestination(stopPosition);

        while (agent.pathPending || agent.remainingDistance > agent.stoppingDistance)
        {
            yield return null;
        }

        if (animator != null)
        {
            animator.SetBool("Moving", false);
        }

        hasReachedBait = true;
        //agent.enabled = false;
        Debug.Log("Done moving towards bait");
    }

    /// <summary>
    /// Helper method that checks if the player has been within avoid distance of the GameObject
    /// for a set amount of time, resetting the avoid speed of the GameObject if the player has not.
    /// </summary>
    IEnumerator AvoidCooldown()
    {
        float elapsedT = 0f;
        while (elapsedT < cooldownTime)
        {
            if (Vector3.Distance(player.position, transform.position) <= avoidDistance)
            {
                yield break;
            }
            elapsedT += Time.deltaTime;
            yield return null;
        }
        increment = 0;
        recentlyAvoided = false;
        agent.speed = baseSpeed;
    }

    /// <summary>
    /// Helper method to temporarily prevent the mammoth from moving
    /// after reaching its bait.
    /// </summary>
    IEnumerator BaitCooldown()
    {
        immobileFromBait = true;
        float elapsedT = 0f;
        while (elapsedT < baitCooldownTime)
        {
            elapsedT += Time.deltaTime;
            yield return null;
        }
        immobileFromBait = false;
    }

    /// <summary>
    /// Update is called once per frame. It is used to check the distance between the player, 
    /// bait, and the GameObject.
    /// </summary>
    void Update()
    {
        if (immobileFromBait)
        {
            return;
        }
        if (hasReachedBait)
        {
            hasReachedBait = false;
            if (currentCoroutine != null)
            {
                StopCoroutine(currentCoroutine);
            }
            currentCoroutine = StartCoroutine(BaitCooldown());
            return;
        }

        float distanceFromPlayer = Vector3.Distance(transform.position, player.position);
        float distanceFromBait = Vector3.Distance(transform.position, bait.position);
        float playerToBaitDistance = Vector3.Distance(player.position, bait.position);

        // Checks if:
        // 1. object is within a certain distance of the bait
        // 2. object is away from the player
        // 3. player is away from the bait
        bool baitDistanceConditionals = distanceFromBait <= baitDetectionDistance &&
                                        distanceFromPlayer > avoidDistance &&
                                        playerToBaitDistance > avoidDistance;

        if (baitDistanceConditionals)
        {
            if (currentCoroutine != null)
            {
                StopCoroutine(currentCoroutine);
            }
            currentCoroutine = StartCoroutine(MoveToBait());
        }
        else if (distanceFromPlayer < avoidDistance && !isAvoiding)
        {
            if (currentCoroutine != null)
            {
                StopCoroutine(currentCoroutine);
            }
            currentCoroutine = StartCoroutine(Avoid());
        }
    }
}